---
title: "Tarea #3 Herramientas de Ciencia de Datos I"
author: 
  - name: "Andrey González Bastos C33329"
  
date: "`r Sys.Date()`"  

format:
  html:
    self-contained: true
    toc: true
    toc_float: true
    df-print: paged
    theme: cosmo
    highlight: tango
---

## 1. Orden de commits al usar ramas

::: {style="text-align: justify;"}
1.1 Explique en sus propias palabras, la diferencia entre los siguientes comandos:

git add: git add se usa cuando hayamos creado o modificado alguno de nuestros archivos en el proyecto y queremos pasarlo a la "fase" de stage, básicamente "añadimos" esos archivos nuevos o cambios para dejarlos listos para posteriormente poder hacer el commit respectivo. El git add es ese paso previo para que git tome en cuenta los cambios que hicimos. Es recomendable usar casi siempre git add (nombre archivo) y no git add . ya que este muchas veces arrastra cambios/archivos que no necesariamente queremos incluir en las modificaciones que estamos realizando.

git commit: Aquí es donde se pasa de la fase de stage a tenerlo casi listo en el server, es básicamente ese paso donde marcamos y explicamos de manera corta y concisa que fue lo que hicimos para dejarlo claro a los compañeros del repositorio. En este paso se deja listo para hacer el git push y finalmente ver los cambios en el server. Los commits deben ser cortos y seguir las convenciones para que su lectura y entendimiento sea ágil, se recomienda no trabajar mucho código y hacer un commit gigante, si no trabajar el código por partes y hacer pequeños commits constantes para que cada commit se entienda mejor.

Básicamente se puede hacer como un diagrama para observar el orden de los pasos

Modifico - git add - ya está en stage - git commit - comento lo que hice - git push - ya se ven esos cambios en el repositorio.

git merge: git merge se usa cuando quiero actualizar la rama master/main e implementar los cambios que he estado trabajando en otras ramas. Por ejemplo si creé una función en mi rama personal de trabajo pero esa función es vital para el proyecto, yo agrego esa función a la rama master/main con un git merge. Este merge fusiona todo lo de la rama en un mismo commit y lo conecta con la rama main, este conserva el historial.

git rebase: git rebase se usa cuando quiero actualizar una rama con los cambios de otra rama, acá no necesariamente tiene que ser la rama main/master. Estos cambios por así decirlo se van hasta el frente, por lo que parece tener una linealidad cronológica más estética. Clona todos los commits en el frente de la rama donde se vayan a meter.

Es conveniente aplicar git merge en vez de rebase cuando se está trabajando solo ya que este presenta una linealidad más entendible, además es importante considerar no se pierde el historial y se considera más seguro que el rebase. Con git merge los problemas pueden ser que el historial queda repleto de git merge y pierde claridad y git rebase presenta problemas como que se reescriben commits y se puede complicar si se está trabajando en grupo.
:::

## 2. Secuencia de comandos

Con la secuencia de comandos dada, se puede concluir que:

::: {style="text-align: justify; text-indent: 20px;"}
1.  Como dice historial limpio y ordenado, se puede intuir que se trata de un rebase, ya que el merge deja un historial más complejo.

Cambiar a rama main primero y luego hacer el rebase, así:

git checkout rama-A

git rebase main

git push origin main

2.  Para este punto ya A metió sus commits al main, entonces B podría hacer

git checkout main

git pull origin main (trae los últimos cambios)

git merge rama-B (hacer un merge de una vez)

git push origin main (subir los cambios)

En general pueden ser muchas formas, tanto que se hagan ambos en merge, ambos en rebase o combinando ambas, esto según el gusto de las personas que estén trabajando en el repositorio.

3.  Se adjunta el dibujo:
:::

![](images/rebase y merge.png)

::: {style="text-align: justify; text-indent: 20px;"}
4.  El git rebase básicamente reescribe el historial y todo lo va haciendo de forma lineal, es más entendible y más limpio para principiantes en git, mientras tanto que git merge hace como un commit donde fusiona todo y este muestra el historial real del trabajo. En mi opinión, si no importa tanto el historial si no el resultado final, usar git rebase es la mejor opción, pues todo va quedando de forma lineal y entendible.
:::

## 3. Uso de repositorios

::: {style="text-align: justify;"}
Primero en el git bash se hace un git clone link del repo para poder acceder al mismo, luego de claro, haber aceptado la invitación. Luego, para crear la carpeta se debe hacer un

mkdir Andrey_Gonzalez_C33329 (esto para crear la carpeta)

Luego, para el archivo se hace fácilmente con un echo

echo "Mi opinión ..." \> Andrey_Gonzalez_Bastos / MiOpinion.txt

Ya solo queda pues hacer el git add, git commit y git push respectivo para subirlo al repo. Este paso se hace exactamente igual para el Tema Favorito y el código en R, el cual se puede hacer directamente en el echo, solo finaliza con .R en lugar de txt y listo.

Para crear una rama se usa git checkout -b AndreyGonzalez

Se hace un commit –allow-empty -m"", el cual básicamente funciona como un commit sin haber editado o agregado algo propiamente.

Se hace un alias con el código git config alias.andreylog "log --oneline --graph --all --decorate", el cual permite ver historial, se adjunta:
:::

![](images/Commits.png)

::: {style="text-align: justify;"}
Ya por último se sube la rama, se hace un rebase y se cambia el readme con su git add, git commit y git push como siempre se ha hecho.
:::

## 4. Resolución de conflictos

::: {style="text-align: justify;"}
-Se creó el repositorio de GitHub público con link: <https://github.com/AndreyGonzalez10/Tarea3_CA0204_C33329.git>

-El .gitignore que se escogió fue el de R que viene en la lista de los que se pueden poner automáticamente con la creación del repositorio. Se escogió este pues se recomienda usar el del respectivo lenguaje en que se vaya a trabajar el proyecto y como se usó la terminal de R, pues se escogió ese. El .gitignore básicamente le dice a git qué archivos, carpetas o documentos no siga ni suba al github.
:::

::: {style="text-align: justify;"}
-El comando para hacer una nueva rama es git checkout -b rama-conflicto.

-Se entra al archivo README.md en los files de R y se añade la línea : Mi comida favorita es la pizza. Se hace el git add README.md para pasarlo a stage y ya se hace el git commit -m "Docs: Se cambia el README" y se hace por último git push origin rama-conflicto para incorporarlo al repositorio en línea.

-Se pasa de rama con git checkout main, luego se entra igualmente al README y se pone la línea: Mi comida favorita es el arroz con pollo. Se hace el git add README.md para pasarlo a stage, luego el git commit -m "Docs: Cambios en el README" y ya por el último el git push origin main para incorporarlo al repositorio.

-Para integrar los cambios en main, basta con posicionarse en la rama main con git checkout main, hacer git pull origin main como buena práctica para tener la última versión y ya luego se hace el git merge rama-conflicto.
:::

-Sale el siguiente conflicto:

![](Captura%20del%20problema.png)

::: {style="text-align: justify;"}
-El archivo se modifica fácilmente, basta con borrar lo que no se desea (git hace la diferencia con marcas) y solo conservar lo que se quiere mantener, puede ser el caso donde se deja todo (se fusiona) pero en mi caso quise mantener la pizza porque me gusta más, entonces borré todo el resto (incluyendo las marcas de que hace git) y solo puse la pizza, guardé el archivo, git add README.md, luego un git commit -m "Docs: Arreglo conflicto ", y por último git push origin main y listo, todo resuelto.
:::
